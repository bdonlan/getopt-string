/* Generated by re2c 0.13.5 on Fri Jul 17 17:54:25 2009 */
#line 1 "parseopt.re2c.c"
#include "parseopt.h"
#include <string.h>
#include <stdlib.h>
#include <glib.h>

struct token {
	GString *str;
	const char *start;
};

struct parsectx {
	const char *p;
	struct token lookahead[2];
	size_t lookahead_sz;
	int all_literal;
};

static void initctx(const char *optstr, struct parsectx *pc) {
	pc->p = optstr;
	pc->lookahead_sz = 0;
	pc->all_literal  = 0;
	for (int i = 0; i < 2; i++)
		pc->lookahead[i].str = g_string_new("");
}

static void freectx(struct parsectx *pc) {
	for (size_t i = 0; i < 2; i++)
		g_string_free(pc->lookahead[i].str, 1);
}

static void consume_token(struct parsectx *pc) {
	GString *temp = pc->lookahead[0].str;
	g_assert(pc->lookahead_sz);
	pc->lookahead_sz--;
	pc->lookahead[0] = pc->lookahead[1];
	pc->lookahead[1].str = temp;
}

static char escape(char e) {
	switch (e) {
		case 'r' : return '\r';
		case 'n' : return '\n';
		case 't' : return '\t';
		default  : return e;
	}
}

static int parse_once(struct parsectx * restrict pc, int index) {
	struct token *t = &pc->lookahead[index];
start:

#line 55 "<stdout>"
	{
		unsigned char yych;

		yych = (unsigned char)*(pc->p);
		switch (yych) {
		case 0x00:	goto yy4;
		case '\t':
		case ' ':	goto yy2;
		default:	goto yy6;
		}
yy2:
		++(pc->p);
#line 65 "parseopt.re2c.c"
		{ goto start; }
#line 70 "<stdout>"
yy4:
		++(pc->p);
#line 66 "parseopt.re2c.c"
		{ pc->p--; return 0; }
#line 75 "<stdout>"
yy6:
		++(pc->p);
#line 67 "parseopt.re2c.c"
		{
		pc->p--;
		goto begin_token;
	}
#line 83 "<stdout>"
	}
#line 71 "parseopt.re2c.c"

begin_token:
	t->start = pc->p;
token_loop:

#line 91 "<stdout>"
	{
		unsigned char yych;
		yych = (unsigned char)*(pc->p);
		switch (yych) {
		case 0x00:	goto yy12;
		case '\t':
		case ' ':	goto yy10;
		case '"':	goto yy16;
		case '\'':	goto yy14;
		case '\\':	goto yy18;
		default:	goto yy20;
		}
yy10:
		++(pc->p);
#line 76 "parseopt.re2c.c"
		{ pc->p--; return 1; }
#line 108 "<stdout>"
yy12:
		++(pc->p);
#line 77 "parseopt.re2c.c"
		{ pc->p--; return 1; }
#line 113 "<stdout>"
yy14:
		++(pc->p);
#line 78 "parseopt.re2c.c"
		{ goto single_quote; }
#line 118 "<stdout>"
yy16:
		++(pc->p);
#line 79 "parseopt.re2c.c"
		{ goto double_quote; }
#line 123 "<stdout>"
yy18:
		++(pc->p);
		if ((yych = (unsigned char)*(pc->p)) >= 0x01) goto yy21;
yy19:
#line 81 "parseopt.re2c.c"
		{ g_string_append_c(t->str, pc->p[-1]); goto token_loop; }
#line 130 "<stdout>"
yy20:
		yych = (unsigned char)*++(pc->p);
		goto yy19;
yy21:
		++(pc->p);
#line 80 "parseopt.re2c.c"
		{ g_string_append_c(t->str, escape(pc->p[-1])); goto token_loop; }
#line 138 "<stdout>"
	}
#line 82 "parseopt.re2c.c"

single_quote:

#line 144 "<stdout>"
	{
		unsigned char yych;
		yych = (unsigned char)*(pc->p);
		switch (yych) {
		case 0x00:	goto yy27;
		case '\'':	goto yy25;
		default:	goto yy29;
		}
yy25:
		++(pc->p);
#line 85 "parseopt.re2c.c"
		{ goto token_loop; }
#line 157 "<stdout>"
yy27:
		++(pc->p);
#line 86 "parseopt.re2c.c"
		{ pc->p--; return 1; }
#line 162 "<stdout>"
yy29:
		++(pc->p);
#line 87 "parseopt.re2c.c"
		{ g_string_append_c(t->str, pc->p[-1]); goto single_quote; }
#line 167 "<stdout>"
	}
#line 88 "parseopt.re2c.c"

double_quote:

#line 173 "<stdout>"
	{
		unsigned char yych;
		yych = (unsigned char)*(pc->p);
		switch (yych) {
		case 0x00:	goto yy35;
		case '"':	goto yy33;
		case '\\':	goto yy37;
		default:	goto yy39;
		}
yy33:
		++(pc->p);
#line 91 "parseopt.re2c.c"
		{ goto token_loop; }
#line 187 "<stdout>"
yy35:
		++(pc->p);
#line 92 "parseopt.re2c.c"
		{ pc->p--; return 1; }
#line 192 "<stdout>"
yy37:
		++(pc->p);
		if ((yych = (unsigned char)*(pc->p)) >= 0x01) goto yy40;
yy38:
#line 94 "parseopt.re2c.c"
		{ g_string_append_c(t->str, pc->p[-1]); goto double_quote; }
#line 199 "<stdout>"
yy39:
		yych = (unsigned char)*++(pc->p);
		goto yy38;
yy40:
		++(pc->p);
#line 93 "parseopt.re2c.c"
		{ g_string_append_c(t->str, escape(pc->p[-1])); goto double_quote; }
#line 207 "<stdout>"
	}
#line 95 "parseopt.re2c.c"

}

static const struct token *get_lookahead(struct parsectx *pc, size_t offset) {
	g_assert(offset < sizeof(pc->lookahead) / sizeof(pc->lookahead[0]));
	while (offset >= pc->lookahead_sz) {
		g_string_assign(pc->lookahead[pc->lookahead_sz].str, "");
		if (parse_once(pc, pc->lookahead_sz))
			pc->lookahead_sz++;
		else {
			return NULL; /* EOI */
		}
	}
	return &pc->lookahead[offset];
}

const char *parseopt_parse(void *baton, const char *argstr, const ParseOptCallbacks *cb) {
	struct parsectx pc;
	initctx(argstr, &pc);

	while (1) {
		const struct token *t = get_lookahead(&pc, 0);
		int ret;
		if (!t)
			break;
		if (pc.all_literal || t->str->str[0] != '-') {
			ret = cb->literalopt(baton, t->str->str, t->start);
			if (ret != PARSEOPT_STOP)
				ret = PARSEOPT_NOARG;
		} else if (t->str->str[1] == '-') {
			if (t->str->str[2] == '\0') {
				pc.all_literal = 1;
			} else {
				int inline_arg;
				const char *argument;
				char *eqp;
				if ((eqp = strchr(&t->str->str[2], '='))) {
					inline_arg = 1;
					*eqp = 0;
					argument = eqp + 1;
				} else {
					const struct token *next = get_lookahead(&pc, 1);
					inline_arg = 0;
					if (next)				
						argument = next->str->str;
					else
						argument = NULL;
				}
				ret = cb->longopt(baton, &t->str->str[2], argument, t->start);
				if (ret == PARSEOPT_EATARG && inline_arg)
					ret = PARSEOPT_NOARG;
			}
		} else {
			ret = PARSEOPT_NOARG;
			for (const char *p = &t->str->str[1]; *p; p++) {
				int inline_arg;
				const char *argp;
				if (p[1]) {
					inline_arg = 1;
					argp = &p[1];
				} else {
					inline_arg = 0;
					const struct token *argt = get_lookahead(&pc, 1);
					if (argt)
						argp = argt->str->str;
					else
						argp = NULL;
				}
				ret = cb->shortopt(baton, *p, argp, t->start);
				if (ret == PARSEOPT_EATARG) {
					if (inline_arg)
						ret = PARSEOPT_NOARG;
					break;
				}
			}
		}
		if (ret == PARSEOPT_STOP) {
			pc.p = t->start;
			break;
		}
		consume_token(&pc);
		if (ret == PARSEOPT_EATARG)
			consume_token(&pc);
	}
	freectx(&pc);
	return pc.p;
}
